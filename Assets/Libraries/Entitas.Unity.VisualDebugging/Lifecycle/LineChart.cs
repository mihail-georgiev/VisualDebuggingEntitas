using UnityEditor;using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Linq;using System.IO;using System;using Eppy;namespace Entitas.Unity.VisualDebugging {	public class LineChart {		float windowHeight;		float chartBorderHorizontal = 60;		float chartBorderVertikal = 20;		int chartSections = 10;		float sectionWidth;		float chartFloor ;		float chartTop;		float timeStep;		Dictionary<String, List<String>> entityEntries;		float lastRecordedTime;					List<Color> colors = new List<Color>{Color.magenta, Color.cyan * 2.0f, Color.green, Color.yellow, Color.red, Color.grey};							float pipRadius = 3.5f;		//for the new stuff		Dictionary<string, List<Tuple<string,string>>>[] sortedEntityData;		HashSet<string> componentList;		string lastLogFilePath;		bool showAllOption = true;		bool showSelectedOption = false;		bool[] selectedComponents;		float timeFrameBeginn,timeFrameEnd; 		public LineChart() {			readEntriesDataFromFile();			newStuff();			int linesToDraw = entityEntries.Count;			float height = linesToDraw*20 +100;			this.windowHeight = height;			selectedComponents = new bool[componentList.Count];			timeFrameBeginn = 0f;			timeFrameEnd = lastRecordedTime/3;		}		public void drawControls() {			EditorGUILayout.HelpBox("Read from file: " + lastLogFilePath + 				"\nLast entry recorded at: " + lastRecordedTime + " ms" +			                        "\nRecorded Entities: " + sortedEntityData.Length, MessageType.Info);			GUIStyle leftmargin = new GUIStyle(GUI.skin.label);			leftmargin.contentOffset = new Vector2(10f,0f);			showAllOption = EditorGUILayout.ToggleLeft("Show all Entity data", !showSelectedOption,leftmargin);			showSelectedOption = EditorGUILayout.ToggleLeft("Show events for selected components only", !showAllOption,leftmargin);			if(showSelectedOption){				EditorGUI.indentLevel++;				EditorGUILayout.BeginVertical();				for(int i =0; i<selectedComponents.Length;i++){					selectedComponents[i] = EditorGUILayout.ToggleLeft(componentList.ElementAt(i), selectedComponents[i],leftmargin);				}				EditorGUI.indentLevel--;				EditorGUILayout.EndVertical();			}			else {				for(int i =0; i<selectedComponents.Length;i++){					selectedComponents[i] = false;				}			}			EditorGUILayout.Separator();			EditorGUILayout.MinMaxSlider(ref timeFrameBeginn, ref timeFrameEnd, 0f, lastRecordedTime);			EditorGUILayout.LabelField("min " + timeFrameBeginn);			EditorGUILayout.LabelField("max " + timeFrameEnd);			EditorGUILayout.LabelField("time frame " + (timeFrameEnd - timeFrameBeginn));			timeStep = (timeFrameEnd - timeFrameBeginn)/chartSections;			chartSections = EditorGUILayout.IntField ("Sections", chartSections);		}		public void DrawChart() {					creteChartRect ();				drawEntityEvents();		    	drawAxisAndEntityLines();				drawSectionsAndLabels();		}			void creteChartRect() {			Rect rect = GUILayoutUtility.GetRect (Screen.width, windowHeight);			chartTop = rect.y + chartBorderVertikal;			sectionWidth = (float)(Screen.width - (chartBorderHorizontal * 2)) / chartSections;			chartFloor = rect.y + rect.height - chartBorderVertikal;		}		void drawAxisAndEntityLines() {					Handles.color = Color.green;			Handles.DrawLine (new Vector2 (chartBorderHorizontal, chartTop), new Vector2 (chartBorderHorizontal, chartFloor));			Handles.DrawLine (new Vector2 (chartBorderHorizontal, chartFloor), new Vector2 (Screen.width, chartFloor));			Handles.color = Color.gray;			for(int i =0; i<sortedEntityData.Length;i++)			{				Handles.DrawLine (new Vector2 (chartBorderHorizontal, -(i+1)*20+chartFloor), new Vector2 (Screen.width, -(i+1)*20+chartFloor));				//colect components				string compList = "";				foreach(var comp in sortedEntityData[i].Keys){					compList+= comp + "\n";				}				//draw enitity line labels in front				GUIStyle colorStyle = new GUIStyle ();				colorStyle.normal.textColor = Color.white;				Rect labelRect = new Rect (1, -(i+1)*20+chartFloor - 8, 100, 16);				GUI.Label (labelRect, new GUIContent("Entity_" + i,compList), colorStyle);			}		}		void drawSectionsAndLabels() {			GUIStyle centeredStyle = new GUIStyle();			centeredStyle.alignment = TextAnchor.UpperCenter;			centeredStyle.normal.textColor = Color.yellow;						for (int i = 0; i <= chartSections; i++) {				if (i > 0)					Handles.DrawLine (new Vector2 (chartBorderHorizontal + (sectionWidth * i), chartFloor - 3), new Vector2 (chartBorderHorizontal + (sectionWidth * i), chartFloor + 3));								Rect labelRect = new Rect (chartBorderHorizontal + (sectionWidth * i) - sectionWidth / 2.0f, chartFloor + 5, sectionWidth, 16);				GUI.Label(labelRect, "" + (timeFrameBeginn + i * timeStep) + "ms", centeredStyle);			}		}		void drawEntityEvents()		{			if(showAllOption)// all components selected			{					for(int i = 0; i<sortedEntityData.Length; i++)				{						int colr = 0;					foreach(string componentKey in sortedEntityData[i].Keys){						Handles.color = colors[colr++];						if(colr> colors.Count-1)							colr = 0;						List<Tuple<string,string>> componentEventList = sortedEntityData[i][componentKey];						foreach(Tuple<string,string> eventEntry in componentEventList)						{							float timeStamp = float.Parse(eventEntry.Item2);							if(timeStamp>= timeFrameBeginn && timeStamp<=timeFrameEnd){								float centerX = chartBorderHorizontal + ((timeStamp-timeFrameBeginn)/(timeFrameEnd-timeFrameBeginn))*(Screen.width - chartBorderHorizontal);								float centerY = -(i+1)*20+chartFloor;								Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);							} 						}					} 				}			}			else{				List<string> comp = new List<string>();				for(int i =0; i < selectedComponents.Length; i++){ //get selected components					if(selectedComponents[i])						comp.Add(componentList.ElementAt(i));				}				//check if entity has this components				List<int> entitiesToDisplay = new List<int>();				for(int i = 0; i<sortedEntityData.Length; i++){					int checker = comp.Count;					foreach(string c in comp){						if(sortedEntityData[i].Keys.Contains(c))							checker--;					}					if(checker == 0)						entitiesToDisplay.Add(i);				}				if(entitiesToDisplay.Count>0)				{					for(int i=0; i<entitiesToDisplay.Count; i++){						int entIndex = entitiesToDisplay[i];						var temp = sortedEntityData[entIndex];						int colr = 0;						foreach(var c in comp){							Handles.color = colors[colr++];							if(colr> colors.Count-1)								colr = 0;							var list = temp[c];							foreach(var l in list){								float timeStamp = float.Parse(l.Item2);								if(timeStamp>= timeFrameBeginn && timeStamp<=timeFrameEnd){									float centerX = chartBorderHorizontal + ((timeStamp-timeFrameBeginn)/(timeFrameEnd-timeFrameBeginn))*(Screen.width - chartBorderHorizontal);									float centerY = -(entIndex+1)*20+chartFloor;									if(timeFrameEnd-timeFrameBeginn<400){										Rect selectRect = new Rect(centerX - pipRadius*2, centerY-pipRadius*2,pipRadius*4, pipRadius*4);										if (selectRect.Contains(Event.current.mousePosition)) {											Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius*2);											GUI.Label (selectRect, new GUIContent("",l.Item1 + " at " + l.Item2));										}										else 											Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);									}									else										Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);								}							}						}					}				}			}		}		void readEntriesDataFromFile() {				string[] allLogFiles = Directory.GetFiles("Assets/Logs/", "*.txt");			lastLogFilePath = allLogFiles[allLogFiles.Length-1];			String[] lines = File.ReadAllLines(lastLogFilePath);			entityEntries = new Dictionary<String, List<String>>();						foreach (string line in lines) {				if(line.Length>1){					string[] split = line.Split(':');										if (!entityEntries.ContainsKey(split[0])) {						entityEntries.Add(split[0], new List<string>());					}					if(split.Length>1)						entityEntries[split[0]].Add(split[1]);				}			}			string lastEntry = lines[(lines.Length) - 1];			lastRecordedTime = float.Parse(lastEntry.Split(new string[]{":"," at "}, StringSplitOptions.None)[2]);		}		void newStuff(){			string[] separators = new string[]{" -> ",","," at "};			sortedEntityData = new Dictionary<string, List<Tuple<string,string>>>[entityEntries.Keys.Count];			int index = 0;			foreach(KeyValuePair<String, List<String>> entry in entityEntries){				sortedEntityData[index] = new Dictionary<string, List<Tuple<string, string>>>();				foreach(string eventEntry in entry.Value){					string[] split = eventEntry.Split(separators,StringSplitOptions.None);					if(!sortedEntityData[index].ContainsKey(split[1])){						sortedEntityData[index].Add(split[1], new List<Tuple<string, string>>());					}						sortedEntityData[index][split[1]].Add(Tuple.Create(split[0] + " " + split[1] + ", " + split[2], split[3]));				}				index++;			}			componentList = new HashSet<string>();			foreach(var dict in sortedEntityData){				foreach(string key in dict.Keys){					componentList.Add(key);				}			}		}	}}