using UnityEditor;using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Linq;using System.IO;using System;using Eppy;namespace Entitas.Unity.VisualDebugging {	public class LineChart {		float chartBorderHorizontal = 60;		float chartBorderVertikal = 20;		int chartSections = 10;		float sectionWidth, chartFloor, chartTop, chartHeight;		float sectionTimeStep;		float timeFrameBeginn = 0f;		float timeFrameEnd, timeFrameSpan;		float lastRecordedTime;		float pipRadius = 3.5f;		Dictionary<String, List<String>> entityEntries;		Dictionary<string, List<Tuple<string,string>>>[] sortedEntityData;				string lastLogFilePath;		HashSet<string> componentList;		bool showAllComponentsOption = true;		bool showSelectedComponentOption = false;		bool[] selectedComponents;		List<Color> colors = new List<Color>{Color.magenta, Color.cyan * 2.0f, Color.green, Color.yellow, Color.red, Color.grey};			GUIStyle toggleGuiStyle, colorStyle, centeredStyle;		public LineChart() {			initChartData();			setToggleGuiStyle();			setColorStyle();			setCenteredStyle();		}		public void drawControls() {			drawHelpBox ();			showAllComponentsOption = EditorGUILayout.ToggleLeft("Show all Entity data", !showSelectedComponentOption,toggleGuiStyle);			showSelectedComponentOption = EditorGUILayout.ToggleLeft("Show events for selected components only", !showAllComponentsOption,toggleGuiStyle);			if(showSelectedComponentOption){				drawComponentTogglesSelection();			}			else {				unmarkAllComponentToggles ();			}			EditorGUILayout.Separator();			EditorGUILayout.MinMaxSlider(ref timeFrameBeginn, ref timeFrameEnd, 0f, lastRecordedTime);			timeFrameSpan = (timeFrameEnd - timeFrameBeginn);			EditorGUILayout.LabelField("Start time frame from: " + timeFrameBeginn);			EditorGUILayout.LabelField("End time frame to: " + timeFrameEnd);			EditorGUILayout.LabelField("Time frame span: " + timeFrameSpan);			sectionTimeStep = timeFrameSpan/chartSections;			chartSections = EditorGUILayout.IntField ("Chart sections", chartSections);		}		public void DrawChart() {				setChartRect ();			drawChartAxis ();			drawSectionsAndLabels();			drawEntityLines();			drawEntityLabelsAndSetPopUps();			drawEntityEvents();  			}		void initChartData() {				lastLogFilePath = getLastLogFile();						entityEntries = readEntityDataFromFile(lastLogFilePath);						sortedEntityData = getSortedEntityData(entityEntries);						componentList = getComponentsList(sortedEntityData);						setChartHeight(entityEntries.Count);						selectedComponents = new bool[componentList.Count];			timeFrameEnd = lastRecordedTime / 3;		}		void setToggleGuiStyle (){			toggleGuiStyle = new GUIStyle(GUI.skin.label);			toggleGuiStyle.contentOffset = new Vector2(10f,0f);		}		void setColorStyle (){			colorStyle = new GUIStyle ();			colorStyle.normal.textColor = Color.white;		}				void setCenteredStyle (){			centeredStyle = new GUIStyle();			centeredStyle.alignment = TextAnchor.UpperCenter;			centeredStyle.normal.textColor = Color.yellow;		}		void drawHelpBox (){			EditorGUILayout.HelpBox ("Read from file: " + lastLogFilePath + 			                         "\nLast entry recorded at: " + lastRecordedTime + " ms" + 			                         "\nRecorded Entities: " + sortedEntityData.Length, MessageType.Info);		}		void drawComponentTogglesSelection(){			EditorGUI.indentLevel++;			EditorGUILayout.BeginVertical();			for(int i =0; i<selectedComponents.Length;i++){				selectedComponents[i] = EditorGUILayout.ToggleLeft(componentList.ElementAt(i), selectedComponents[i],toggleGuiStyle);			}			EditorGUI.indentLevel--;			EditorGUILayout.EndVertical();		}		void unmarkAllComponentToggles (){			for (int i = 0; i < selectedComponents.Length; i++) {				selectedComponents [i] = false;			}		}		void setChartRect() {			Rect rect = GUILayoutUtility.GetRect (Screen.width, chartHeight);			chartTop = rect.y + chartBorderVertikal;			sectionWidth = (float)(Screen.width - (chartBorderHorizontal * 2)) / chartSections;			chartFloor = rect.y + rect.height - chartBorderVertikal;		}		void drawChartAxis (){			Handles.color = Color.green;			Handles.DrawLine (new Vector2 (chartBorderHorizontal, chartTop), new Vector2 (chartBorderHorizontal, chartFloor));			Handles.DrawLine (new Vector2 (chartBorderHorizontal, chartFloor), new Vector2 (Screen.width, chartFloor));		}		void drawSectionsAndLabels() {			for (int i = 0; i <= chartSections; i++) {				if (i > 0)					Handles.DrawLine (new Vector2 (chartBorderHorizontal + (sectionWidth * i), chartFloor - 3), new Vector2 (chartBorderHorizontal + (sectionWidth * i), chartFloor + 3));								Rect labelRect = new Rect (chartBorderHorizontal + (sectionWidth * i) - sectionWidth / 2.0f, chartFloor + 5, sectionWidth, 16);				GUI.Label(labelRect, "" + (timeFrameBeginn + i * sectionTimeStep) + "ms", centeredStyle);			}		}		void drawEntityLines() {					Handles.color = Color.gray;			for(int i =0; i<sortedEntityData.Length;i++){				Handles.DrawLine (new Vector2 (chartBorderHorizontal, -(i+1)*20+chartFloor), new Vector2 (Screen.width, -(i+1)*20+chartFloor));			}		}		void drawEntityLabelsAndSetPopUps (){				for(int i =0; i<sortedEntityData.Length;i++){				//colect components for each entity				string entityCompList = "";				foreach(var comp in sortedEntityData[i].Keys){					entityCompList+= comp + "\n";				}				//draw enitity labels 				Rect labelRect = new Rect (1, -(i+1)*20+chartFloor - 8, 100, 16);				GUI.Label (labelRect, new GUIContent("Entity_" + i,entityCompList), colorStyle);			}		}		void drawEntityEvents(){			if(showAllComponentsOption){					drawAllEntityEvents();			}else{				List<string> selectedCompList = getListSelectedComp();				List<int> indexList = getEntitiesContainingSelectedComp(selectedCompList);				if(indexList.Count>0)				{					drawEventsForSelectedComponents(selectedCompList, indexList);				}			}		}		string getLastLogFile(){			string[] allLogFiles = Directory.GetFiles("Assets/Logs/", "*.txt");			return allLogFiles[allLogFiles.Length-1];		}		Dictionary<String, List<String>> readEntityDataFromFile(string path){			Dictionary<String, List<String>> data = new Dictionary<String, List<String>>();			String[] lines = File.ReadAllLines(path);						foreach (string line in lines) {				if(line.Length>1){					string[] split = line.Split(':');										if (!data.ContainsKey(split[0])) {						data.Add(split[0], new List<string>());					}					if(split.Length>1)						data[split[0]].Add(split[1]);				}			}						setLastRecordedTime(lines);						return data;		}		Dictionary<string, List<Tuple<string,string>>>[] getSortedEntityData(Dictionary<String, List<String>> rawData){			Dictionary<string, List<Tuple<string,string>>>[] sortedData = new Dictionary<string, List<Tuple<string,string>>>[rawData.Keys.Count];			string[] separators = new string[]{" -> ",","," at "};			int index = 0;			foreach(KeyValuePair<String, List<String>> entry in rawData){				sortedData[index] = new Dictionary<string, List<Tuple<string, string>>>();				foreach(string eventEntry in entry.Value){					string[] split = eventEntry.Split(separators,StringSplitOptions.None);					if(!sortedData[index].ContainsKey(split[1])){						sortedData[index].Add(split[1], new List<Tuple<string, string>>());					}					sortedData[index][split[1]].Add(Tuple.Create(split[0] + " " + split[1] + ", " + split[2], split[3]));				}				index++;			}						return sortedData;		}		HashSet<string> getComponentsList(Dictionary<string, List<Tuple<string,string>>>[] entityData){			HashSet<string> compSet = new HashSet<string>();			foreach(var dict in entityData){				foreach(string key in dict.Keys){					compSet.Add(key);				}			}			return compSet;		}		void setChartHeight (int linesToDraw){			float height = linesToDraw * 20 + 100;			chartHeight = height;		}		void drawAllEntityEvents (){			for(int i = 0; i<sortedEntityData.Length; i++){					int colr = 0;				foreach(string componentKey in sortedEntityData[i].Keys){					Handles.color = colors[colr++];					if(colr> colors.Count-1)						colr = 0;					List<Tuple<string,string>> componentEventList = sortedEntityData[i][componentKey];					foreach(Tuple<string,string> eventEntry in componentEventList)					{						float timeStamp = float.Parse(eventEntry.Item2);						if(timeStamp>= timeFrameBeginn && timeStamp<=timeFrameEnd){							float centerX = chartBorderHorizontal + ((timeStamp-timeFrameBeginn)/timeFrameSpan)*(Screen.width - chartBorderHorizontal);							float centerY = -(i+1)*20+chartFloor;														if(timeFrameSpan<400){								Rect selectRect = new Rect(centerX - pipRadius*2, centerY-pipRadius*2,pipRadius*4, pipRadius*4);								if (selectRect.Contains(Event.current.mousePosition)) {									Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius*2);									GUI.Label (selectRect, new GUIContent("",eventEntry.Item1 + " at " + eventEntry.Item2));								}else 									Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);							}							else								Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);						} 					}				} 			}		}		List<string> getListSelectedComp (){			List<string> list = new List<string>();			for(int i =0; i < selectedComponents.Length; i++){				if(selectedComponents[i])					list.Add(componentList.ElementAt(i));			}			return list;		}		List<int> getEntitiesContainingSelectedComp (List<string> selectedComp){			List<int> list = new List<int>();						for(int i = 0; i<sortedEntityData.Length; i++){				int checker = selectedComp.Count;				foreach(string c in selectedComp){					if(sortedEntityData[i].Keys.Contains(c))						checker--;				}				if(checker == 0)					list.Add(i);			}			return list;		}		void drawEventsForSelectedComponents(List<string> compList, List<int> indices){			for(int i=0; i<indices.Count; i++){				int entityIndex = indices[i];				var singleEntityData = sortedEntityData[entityIndex];				int color = 0;				foreach(var component in compList){					Handles.color = colors[color++];					if(color> colors.Count-1)						color = 0;					var componentEventsList = singleEntityData[component];					foreach(var listEntry in componentEventsList){						float listEntryTimeStamp = float.Parse(listEntry.Item2);						if(listEntryTimeStamp>= timeFrameBeginn && listEntryTimeStamp<=timeFrameEnd){							float centerX = chartBorderHorizontal + ((listEntryTimeStamp-timeFrameBeginn)/(timeFrameSpan))*(Screen.width - chartBorderHorizontal);							float centerY = -(entityIndex+1)*20+chartFloor;																					if(timeFrameSpan<400){								Rect selectRect = new Rect(centerX - pipRadius*2, centerY-pipRadius*2,pipRadius*4, pipRadius*4);								if (selectRect.Contains(Event.current.mousePosition)) {									Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius*2);									GUI.Label (selectRect, new GUIContent("",listEntry.Item1 + " at " + listEntry.Item2));								}								else 									Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);							}							else								Handles.DrawSolidDisc(new Vector2(centerX,centerY), Vector3.forward, pipRadius);						}					}				}			}		} 		void setLastRecordedTime (string[] fileLines){			for(int i = fileLines.Length-1; i>fileLines.Length-10; i--){				if(fileLines[i] != ""){					string lastEntry = fileLines[i];					lastRecordedTime = float.Parse(lastEntry.Split(new string[]{":"," at "}, StringSplitOptions.None)[2]);					return;				}			}		}	}}